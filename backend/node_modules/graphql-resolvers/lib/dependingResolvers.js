'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveDependees = exports.resolveDependee = exports.isDependee = undefined;

var _objectPath = require('object-path');

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _utils = require('./utils');

var _allResolvers = require('./allResolvers');

var _pipeResolvers = require('./pipeResolvers');

var _combineResolvers = require('./combineResolvers');

var _miscResolvers = require('./miscResolvers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Piping resolver to save current value and reference to dependees cache.
 */
var saveDependee = (0, _combineResolvers.combineResolvers)(_miscResolvers.contextMustBeObject, function (value, args, context, info) {
  return (0, _objectPath.push)(context, '_dependees', { path: info.path, value: value }), value;
});

/**
 * Identify a resolver as being a dependee, so other sibling
 * field resolvers might depend on the value resolved by this one.
 *
 * Basically, it will polute "info" during resolving
 * to insert the resolved value and path to this resolver.
 *
 * @param {Function} resolver Resolver implementation.
 * @return {Promise}.
 */
var isDependee = exports.isDependee = function isDependee(resolver) {
  return function (root) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return saveDependee.apply(undefined, [resolver.apply(undefined, [root].concat(args))].concat(args));
  };
};

/**
 * Make sure the field name exists on the parent type.
 *
 * @param {String} dependeeName The name of the dependee to check the parent against
 * @return {Function} Resolver to error when no dependee is found.
 */
var dependeeExists = function dependeeExists(dependeeName) {
  return function (root, args, context, _ref) {
    var fieldName = _ref.fieldName,
        _ref$parentType = _ref.parentType,
        _fields = _ref$parentType._fields,
        parent = _ref$parentType.name;
    return !_fields[dependeeName] ? new Error('Cannot get dependee "' + dependeeName + '" from field "' + fieldName + '" on type "' + parent + '"') : _utils.skip;
  };
};

/**
 * Resolver implementation to retrieve the resolved value of a dependee sibling field.
 *
 * @param {String} dependeeName The name of the dependee this resolver depends on.
 * @param {Function} resolver Resolver implemenatation.
 * @return {Function} dependee resolver.
 */
var resolveDependee = exports.resolveDependee = function resolveDependee(dependeeName) {
  return (0, _combineResolvers.combineResolvers)(_miscResolvers.contextMustBeObject, dependeeExists(dependeeName), (0, _pipeResolvers.pipeResolvers)(
  // Make sure dependent resolvers occur after
  // dependees have been initialized.
  _utils.nextTick,

  // Find any currently resolved dependee.
  function (root, args, _ref2, info) {
    var _ref2$_dependees = _ref2._dependees,
        _dependees = _ref2$_dependees === undefined ? [] : _ref2$_dependees;

    return _dependees.filter(function (_ref3) {
      var prev = _ref3.path.prev;
      return (0, _deepEqual2.default)(prev, info.path.prev);
    }).find(function (_ref4) {
      var key = _ref4.path.key;
      return key === dependeeName;
    });
  },

  // Run field resolution, if resolved value was not found.
  function (resolved, args, context, info) {
    return resolved === _utils.skip ? info.parentType._fields[dependeeName].resolve(info.rootValue, args, context, info) : resolved.value;
  }));
};

/**
 * Resolver implementation to retrieve the resolved value of multiple dependee sibling fields.
 *
 * @param {[String]} dependeeNames Array of names of the dependees this resolver depends on.
 * @param {Function} resolver Resolver implemenatation.
 * @return {Function} dependee resolver.
 */
var resolveDependees = exports.resolveDependees = function resolveDependees(dependeeNames) {
  return (0, _combineResolvers.combineResolvers)(_miscResolvers.contextMustBeObject, (0, _allResolvers.allResolvers)(dependeeNames.map(resolveDependee)));
};